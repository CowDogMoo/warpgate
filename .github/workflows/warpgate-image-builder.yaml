---
name: Warpgate Image Builder
on:
  workflow_dispatch:
  pull_request:
  push:
    branches: [main]

concurrency:
  cancel-in-progress: true
  group: "${{ github.workflow }}"

env:
  AWS_DEFAULT_REGION: us-west-1
  DEBIAN_FRONTEND: noninteractive
  GO_VERSION: 1.24.0
  PACKER_VERSION: latest
  PYTHON_VERSION: 3.12.6
  RUNZERO_DOWNLOAD_TOKEN: ${{ secrets.RUNZERO_DOWNLOAD_TOKEN }}
  TZ: UTC
  TASK_X_REMOTE_TASKFILES: 1
  TASK_VERSION: 3.38.0

# Required for OIDC
permissions:
  id-token: write
  contents: read
  packages: write

jobs:
  image-builder:
    name: Build container images using go-task
    runs-on: ubuntu-latest
    strategy:
      matrix:
        blueprint:
          - name: sliver
            provision_repo: ansible-collection-arsenal
          - name: atomic-red-team
            provision_repo: ansible-collection-arsenal
          - name: attack-box
            provision_repo: ansible-collection-arsenal
          - name: runzero-explorer
            provision_repo: ansible-collection-bulwark
          - name: ttpforge
            provision_repo: ansible-collection-arsenal
      fail-fast: false
    steps:
      - name: Checkout
        uses: actions/checkout@11bd71901bbe5b1630ceea73d27597364c9af683 # v4.2.2

      - name: Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@e3dd6a429d7300a6a4c196c26e071d42e0343502 # v4
        with:
          aws-region: ${{ env.AWS_DEFAULT_REGION }}
          role-to-assume: ${{ secrets.OIDC_ROLE_ARN }}
          role-session-name: Warpgate-Image-Builder
          role-duration-seconds: 7200

      - name: Setup QEMU
        uses: docker/setup-qemu-action@29109295f81e9208d7d86ff1c6c12d2833863392 # v3

      - name: Setup Docker Buildx
        uses: docker/setup-buildx-action@b5ca514318bd6ebac0fb2aedd5d36ec1b5c232a2 # v3

      - name: Cache Docker layers
        uses: actions/cache@5a3ec84eff668545956fd18022155c47e93e2684 # v4
        with:
          path: /tmp/.buildx-cache
          key: ${{ runner.os }}-buildx-${{ github.sha }}
          restore-keys: |
            ${{ runner.os }}-buildx-

      - name: Install system dependencies
        run: |
          sudo apt-get update
          sudo apt-get install -y build-essential \
                                  btrfs-progs \
                                  fuse-overlayfs \
                                  libgpgme-dev \
                                  libbtrfs-dev \
                                  pkg-config \
                                  slirp4netns \
                                  uidmap
          export XDG_RUNTIME_DIR=/run/user/$(id -u)
          export XDG_CONFIG_HOME=/root/.config
          export XDG_DATA_HOME=/root/.local/share
          echo "export XDG_RUNTIME_DIR=/run/user/$(id -u)" >> $GITHUB_ENV
          echo "export XDG_CONFIG_HOME=/root/.config" >> $GITHUB_ENV
          echo "export XDG_DATA_HOME=/root/.local/share" >> $GITHUB_ENV

      - name: Setup Go
        uses: actions/setup-go@d35c59abb061a4a6fb18e82ac0862c26744d6ab5 # v5
        with:
          go-version: ${{ env.GO_VERSION }}
          check-latest: true
          cache: true
          cache-dependency-path: |
            **/go.sum
            test/go.sum

      - name: Setup go-task
        uses: rnorton5432/setup-task@eec4717ae80f02d1614a4fecfa4a55d507768696 # v1.0.0
        if: always()
        with:
          task-version: ${{ env.TASK_VERSION }}

      - name: Set up Python
        uses: actions/setup-python@8d9ed9ac5c53483de85588cdf95a591a75ab9f55 # v5.5.0
        with:
          python-version: ${{ env.PYTHON_VERSION }}

      - name: Install ansible
        run: python3 -m pip install ansible

      - name: Install yq
        run: go install github.com/mikefarah/yq/v4@latest

      - name: Setup `packer`
        uses: hashicorp/setup-packer@main
        id: setup
        with:
          version: ${{ env.PACKER_VERSION }}

      - name: Free up disk space
        run: |
          sudo rm -rf /usr/share/dotnet
          sudo rm -rf /opt/ghc
          sudo rm -rf "/usr/local/share/boost"
          sudo rm -rf "$AGENT_TOOLSDIRECTORY"

      - name: Configure containers storage to use vfs driver and ignore chown errors
        run: |
          sudo rm -rf /var/lib/containers/storage
          sudo rm -rf /root/.local/share/containers/storage

          sudo mkdir -p /root/.config/containers
          sudo mkdir -p /root/.local/share/containers/storage/vfs/dir

          sudo bash -c 'cat <<EOF > /root/.config/containers/storage.conf
          [storage]
            driver = "vfs"
            runroot = "/run/user/$(id -u)/containers"
            graphroot = "/root/.local/share/containers/storage"
          [storage.options]
            mount_program = "/usr/bin/fuse-overlayfs"
          [storage.options.overlay]
            ignore_chown_errors = "true"
          EOF'

      - name: Clone ansible-collection repositories
        run: |
          mkdir -p $HOME/CowDogMoo
          git clone https://github.com/CowDogMoo/ansible-collection-workstation.git $HOME/CowDogMoo/ansible-collection-workstation
          git clone https://github.com/l50/ansible-collection-arsenal.git $HOME/ansible-collection-arsenal
          git clone https://github.com/l50/ansible-collection-bulwark.git $HOME/ansible-collection-bulwark

      - name: Docker login
        run: |
          echo "${{ secrets.BOT_TOKEN }}" | docker login ghcr.io -u ${{ github.actor }} --password-stdin

      - name: Set specific provision paths and variables
        id: set-vars
        run: |
          BLUEPRINT="${{ matrix.blueprint.name }}"
          PROVISION_REPO="${{ matrix.blueprint.provision_repo }}"

          if [[ "$BLUEPRINT" == "sliver" ]]; then
            echo "provision_path=$HOME/ansible-collection-arsenal" >> $GITHUB_ENV
            echo "vars=workstation_repo_path=${HOME}/CowDogMoo/ansible-collection-workstation arsenal_repo_path=${HOME}/ansible-collection-arsenal blueprint_name=sliver" >> $GITHUB_ENV
          elif [[ "$BLUEPRINT" == "runzero-explorer" ]]; then
            echo "provision_path=$HOME/ansible-collection-bulwark" >> $GITHUB_ENV
            echo "vars=provision_repo_path=${HOME}/ansible-collection-bulwark blueprint_name=runzero-explorer" >> $GITHUB_ENV
          else
            echo "provision_path=$HOME/ansible-collection-arsenal" >> $GITHUB_ENV
            echo "vars=provision_repo_path=${HOME}/ansible-collection-arsenal blueprint_name=$BLUEPRINT" >> $GITHUB_ENV
          fi

          echo "only=$BLUEPRINT-docker.docker.*" >> $GITHUB_ENV

      - name: Run image builder for blueprint
        run: |
          export RUNZERO_DOWNLOAD_TOKEN="${{ secrets.RUNZERO_DOWNLOAD_TOKEN }}"
          export TASK_X_REMOTE_TASKFILES=1

          BLUEPRINT="${{ matrix.blueprint.name }}"
          TEMPLATE_DIR="blueprints/$BLUEPRINT/packer_templates"

          echo "Building image for blueprint: $BLUEPRINT"
          echo "Template directory: $TEMPLATE_DIR"
          echo "Only: ${{ env.only }}"
          echo "Provision path: ${{ env.provision_path }}"
          echo "Variables: ${{ env.vars }}"

          timeout 2h task -y template-build \
            TEMPLATE_DIR=$TEMPLATE_DIR \
            TEMPLATE_NAME=$BLUEPRINT \
            ONLY="${{ env.only }}" \
            VARS="${{ env.vars }}"
        working-directory: ${{ github.workspace }}

      - name: Verify pushed images
        run: |
          echo "${{ secrets.BOT_TOKEN }}" | docker login ghcr.io -u ${{ github.actor }} --password-stdin
          blueprint_name="${{ matrix.blueprint.name }}"
          tag_name=$(yq e '.blueprint.packer_templates.tag.name' "blueprints/$blueprint_name/config.yaml" || echo "undefined")

          if [[ "$tag_name" == "undefined" ]]; then
            # Fallback to the standard format if tag name is not found
            repo_owner=$(echo "${{ github.repository_owner }}" | tr '[:upper:]' '[:lower:]')
            image_name="ghcr.io/$repo_owner/$blueprint_name:latest"
          else
            repo_owner=$(echo "$tag_name" | cut -d'/' -f1)
            image_name="ghcr.io/$tag_name:latest"
          fi

          echo "Verifying image: $image_name"
          docker pull "$image_name"
