---
# yaml-language-server: $schema=https://taskfile.dev/schema.json
version: "3"

vars:
  VERSION:
    sh: git describe --tags --always --dirty 2>/dev/null || echo "dev"
  COMMIT:
    sh: git rev-parse --short HEAD 2>/dev/null || echo "unknown"
  DATE:
    sh: date -u +%Y-%m-%dT%H:%M:%SZ
  LDFLAGS: -s -w -X main.version={{.VERSION}} -X main.commit={{.COMMIT}} -X main.date={{.DATE}}
  HOST_OS:
    sh: go env GOOS
  HOST_ARCH:
    sh: go env GOARCH

includes:
  docker:
    taskfile: "https://raw.githubusercontent.com/CowDogMoo/taskfile-templates/main/docker/Taskfile.yaml"
  github:
    taskfile: "https://raw.githubusercontent.com/CowDogMoo/taskfile-templates/main/github/Taskfile.yaml"
  pre-commit:
    taskfile: "https://raw.githubusercontent.com/CowDogMoo/taskfile-templates/main/pre-commit/Taskfile.yaml"
  secrets:
    taskfile: "https://raw.githubusercontent.com/CowDogMoo/taskfile-templates/main/secrets/Taskfile.yaml"
  renovate:
    taskfile: "https://raw.githubusercontent.com/CowDogMoo/taskfile-templates/main/renovate/Taskfile.yaml"

tasks:
  default:
    desc: Build, test, and clean
    cmds:
      - task: clean
      - task: build
      - task: test

  build:
    desc: Build warpgate binary for current platform
    deps:
      - tidy
    cmds:
      - echo "Building warpgate for {{.HOST_OS}}/{{.HOST_ARCH}}"
      - go build -ldflags "{{.LDFLAGS}}" -o warpgate ./cmd/warpgate
    sources:
      - cmd/**/*.go
      - pkg/**/*.go
      - go.mod
      - go.sum
    generates:
      - warpgate

  build-all:
    desc: Build for all supported platforms
    deps:
      - build-linux
      - build-darwin
      - build-windows

  build-linux:
    desc: Build for Linux (amd64, arm64, armv7)
    deps:
      - build-linux-amd64
      - build-linux-arm64
      - build-linux-arm

  build-linux-amd64:
    desc: Build warpgate for linux/amd64
    deps:
      - tidy
    cmds:
      - mkdir -p dist
      - GOOS=linux GOARCH=amd64 go build -ldflags "{{.LDFLAGS}}" -o dist/warpgate-linux-amd64 ./cmd/warpgate
    sources:
      - cmd/**/*.go
      - pkg/**/*.go
    generates:
      - dist/warpgate-linux-amd64

  build-linux-arm64:
    desc: Build warpgate for linux/arm64
    deps:
      - tidy
    cmds:
      - mkdir -p dist
      - GOOS=linux GOARCH=arm64 go build -ldflags "{{.LDFLAGS}}" -o dist/warpgate-linux-arm64 ./cmd/warpgate
    sources:
      - cmd/**/*.go
      - pkg/**/*.go
    generates:
      - dist/warpgate-linux-arm64

  build-linux-arm:
    desc: Build warpgate for linux/arm (armv7)
    deps:
      - tidy
    cmds:
      - mkdir -p dist
      - GOOS=linux GOARCH=arm GOARM=7 go build -ldflags "{{.LDFLAGS}}" -o dist/warpgate-linux-armv7 ./cmd/warpgate
    sources:
      - cmd/**/*.go
      - pkg/**/*.go
    generates:
      - dist/warpgate-linux-armv7

  build-darwin:
    desc: Build for macOS (amd64, arm64)
    deps:
      - build-darwin-amd64
      - build-darwin-arm64

  build-darwin-amd64:
    desc: Build warpgate for darwin/amd64
    deps:
      - tidy
    cmds:
      - mkdir -p dist
      - GOOS=darwin GOARCH=amd64 go build -ldflags "{{.LDFLAGS}}" -o dist/warpgate-darwin-amd64 ./cmd/warpgate
    sources:
      - cmd/**/*.go
      - pkg/**/*.go
    generates:
      - dist/warpgate-darwin-amd64

  build-darwin-arm64:
    desc: Build warpgate for darwin/arm64
    deps:
      - tidy
    cmds:
      - mkdir -p dist
      - GOOS=darwin GOARCH=arm64 go build -ldflags "{{.LDFLAGS}}" -o dist/warpgate-darwin-arm64 ./cmd/warpgate
    sources:
      - cmd/**/*.go
      - pkg/**/*.go
    generates:
      - dist/warpgate-darwin-arm64

  build-windows:
    desc: Build for Windows (amd64)
    deps:
      - build-windows-amd64

  build-windows-amd64:
    desc: Build warpgate for windows/amd64
    deps:
      - tidy
    cmds:
      - mkdir -p dist
      - GOOS=windows GOARCH=amd64 go build -ldflags "{{.LDFLAGS}}" -o dist/warpgate-windows-amd64.exe ./cmd/warpgate
    sources:
      - cmd/**/*.go
      - pkg/**/*.go
    generates:
      - dist/warpgate-windows-amd64.exe

  clean:
    desc: Clean build artifacts
    cmds:
      - rm -f warpgate warpgate
      - rm -rf dist/
      - go clean

  test:
    desc: Run tests
    cmds:
      - go test -v -race -coverprofile=coverage.out ./...

  test-coverage:
    desc: Run tests with coverage report
    deps:
      - test
    cmds:
      - go tool cover -html=coverage.out -o coverage.html
      - echo "Coverage report generated at coverage.html"

  lint:
    desc: Run linter (requires golangci-lint)
    cmds:
      - golangci-lint run ./...

  fmt:
    desc: Format code
    cmds:
      - go fmt ./...

  tidy:
    desc: Tidy dependencies
    cmds:
      - go mod tidy

  install:
    desc: Install warpgate to GOPATH/bin
    deps:
      - tidy
    cmds:
      - go install -ldflags "{{.LDFLAGS}}" ./cmd/warpgate
      - echo "Installed to $(go env GOPATH)/bin/warpgate"

  show-arch:
    desc: Show detected architecture and build strategy
    cmds:
      - echo "Host OS{{":"}} {{.HOST_OS}}"
      - echo "Host ARCH{{":"}} {{.HOST_ARCH}}"
      - echo "Version{{":"}} {{.VERSION}}"
      - echo "Build strategy{{":"}} native"

  run:
    desc: Build and run warpgate
    deps:
      - build
    cmds:
      - ./warpgate {{.CLI_ARGS}}

  dev:
    desc: Run in development mode with verbose logging
    deps:
      - build
    cmds:
      - ./warpgate --verbose {{.CLI_ARGS}}

  # CI/CD specific tasks
  ci-test:
    desc: Run tests for CI/CD (with JSON output)
    cmds:
      - go test -v -race -coverprofile=coverage.out -json ./... > test-results.json
      - go tool cover -func=coverage.out

  ci-build:
    desc: Build for CI/CD environment
    cmds:
      - task: build
      - task: test
      - echo "Build completed successfully"

  # Architecture-specific CI tasks
  ci-build-native:
    desc: Build for native architecture in CI
    cmds:
      - echo "Building for native arch{{":"}} {{.HOST_ARCH}}"
      - task: build
      - file warpgate || true

  ci-matrix:
    desc: Show build matrix for CI/CD
    cmds:
      - |
        echo "Recommended CI/CD build matrix:"
        echo "  - arch: amd64"
        echo "    runner: ubuntu-latest"
        echo "    strategy: native"
        echo ""
        echo "  - arch: arm64"
        echo "    runner: ubuntu-24.04-arm"
        echo "    strategy: native"

  # Release tasks
  release:
    desc: Create and push a new release tag (triggers goreleaser GHA)
    vars:
      TAG: '{{.TAG | default ""}}'
    preconditions:
      - sh: command -v gh
        msg: "gh CLI is required. Install from https://cli.github.com/"
      - sh: '[ -n "{{.TAG}}" ]'
        msg: "TAG is required. Usage: task release TAG=v1.0.0"
      - sh: git diff --quiet
        msg: "Working directory is not clean. Commit or stash changes first."
      - sh: git diff --cached --quiet
        msg: "Staged changes detected. Commit or unstage changes first."
    cmds:
      - echo "Creating release tag {{.TAG}}..."
      - git tag -a {{.TAG}} -m "Release {{.TAG}}"
      - echo "Pushing tag {{.TAG}} to remote..."
      - git push origin {{.TAG}}
      - echo "Tag pushed successfully. GoReleaser GitHub Action will build and publish the release."
      - echo "Monitor the release at$(":")"
      - gh run list --workflow=goreleaser.yaml --limit 1

  release-check:
    desc: Check if a release exists and view its status
    vars:
      TAG: '{{.TAG | default ""}}'
    preconditions:
      - sh: command -v gh
        msg: "gh CLI is required. Install from https://cli.github.com/"
    cmds:
      - |
        if [ -n "{{.TAG}}" ]; then
          echo "Checking release status for {{.TAG}}..."
          gh release view {{.TAG}} || echo "Release {{.TAG}} not found"
        else
          echo "Latest releases:"
          gh release list --limit 5
        fi

  release-watch:
    desc: Watch the goreleaser workflow run in real-time
    preconditions:
      - sh: command -v gh
        msg: "gh CLI is required. Install from https://cli.github.com/"
    cmds:
      - |
        echo "Watching latest goreleaser workflow run..."
        RUN_ID=$(gh run list --workflow=goreleaser.yaml --limit 1 --json databaseId --jq '.[0].databaseId')
        if [ -n "$RUN_ID" ]; then
          gh run watch $RUN_ID
        else
          echo "No goreleaser workflow runs found"
        fi

  release-test:
    desc: Test goreleaser locally (snapshot build, no publish)
    preconditions:
      - sh: command -v goreleaser
        msg: "goreleaser is required. Install from https://goreleaser.com/install/"
    cmds:
      - echo "Running goreleaser in snapshot mode (no publish)..."
      - goreleaser release --snapshot --clean --skip=publish
      - echo "Snapshot build completed. Check dist/ directory for artifacts."

  release-draft:
    desc: Create a draft release with gh CLI
    vars:
      TAG: '{{.TAG | default ""}}'
      TITLE: '{{.TITLE | default .TAG}}'
      NOTES: '{{.NOTES | default ""}}'
    preconditions:
      - sh: command -v gh
        msg: "gh CLI is required. Install from https://cli.github.com/"
      - sh: '[ -n "{{.TAG}}" ]'
        msg: "TAG is required. Usage: task release-draft TAG=v1.0.0"
    cmds:
      - |
        echo "Creating draft release for {{.TAG}}..."
        if [ -n "{{.NOTES}}" ]; then
          gh release create {{.TAG}} --draft --title "{{.TITLE}}" --notes "{{.NOTES}}"
        else
          gh release create {{.TAG}} --draft --title "{{.TITLE}}" --generate-notes
        fi
        echo "Draft release created. Edit and publish it at:"
        gh release view {{.TAG}} --web

  release-delete:
    desc: Delete a release and its tag
    vars:
      TAG: '{{.TAG | default ""}}'
    preconditions:
      - sh: command -v gh
        msg: "gh CLI is required. Install from https://cli.github.com/"
      - sh: '[ -n "{{.TAG}}" ]'
        msg: "TAG is required. Usage: task release-delete TAG=v1.0.0"
    prompt: "Are you sure you want to delete release {{.TAG}}? This will also delete the git tag."
    cmds:
      - echo "Deleting release {{.TAG}}..."
      - gh release delete {{.TAG}} --yes || echo "Release not found on GitHub"
      - echo "Deleting local tag {{.TAG}}..."
      - git tag -d {{.TAG}} || echo "Local tag not found"
      - echo "Deleting remote tag {{.TAG}}..."
      - git push origin :refs/tags/{{.TAG}} || echo "Remote tag not found"
      - echo "Release and tag deleted successfully."

  release-changelog:
    desc: Generate changelog between two tags
    vars:
      FROM: '{{.FROM | default ""}}'
      TO: '{{.TO | default "HEAD"}}'
    cmds:
      - |
        if [ -z "{{.FROM}}" ]; then
          # Get the latest tag if FROM not specified
          LATEST_TAG=$(git describe --tags --abbrev=0 2>/dev/null || echo "")
          if [ -z "$LATEST_TAG" ]; then
            echo "No previous tags found. Showing all commits:"
            git log --oneline --decorate
          else
            echo "Changelog since $LATEST_TAG:"
            git log ${LATEST_TAG}..{{.TO}} --oneline --decorate
          fi
        else
          echo "Changelog from {{.FROM}} to {{.TO}}:"
          git log {{.FROM}}..{{.TO}} --oneline --decorate
        fi
